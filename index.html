<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
    <link rel="stylesheet" href="css/main.css">
    <title>Udemy JS Course</title>
</head>
<body>

    <header></header>

    <section>
        <h1>Javascript</h1>
            <p>
                Just taking a refresher course in JS for fun and hopefully to learn something new: like some ES6.
            </p>

        <h3>Variables</h3>
        <p>
            Var assigns a variable to function scope, even if that function is the window(global scope). 
                To access a global scope variable that has been re-defined inside a function scope you can use "window.someVariable" to get the original value.

            Let is a block scope assignment. (es6)
                Variables declared using 'let' are not attached to the global/window object and they only work in the scope for which they are declared.
                Variable name declared with 'let' are "locked". You can't re-assign them to change the variable type (ex: string to array) like you can with 'var'.
                Hoisting doesn't work for 'let'.


            Const (es6)
                The 'const' variable is block scoped, immutable and not attached to the window object so it isn't hoisted. 
                You can add new properties to this object making it useful for factory functions.


        </p>

        <h3>Data Types</h3>
        <p>
            String
            Number
            Boolean
            Date
        </p>

        <h3>Strings</h3>
        <p>
            var string = 'some string';
            string.length;
            string.indexOf('string'); 
                returns -1 if 'string' not found
                takes a second parameter indicating the start point of the search: string.indexOf('string', 10);
            string.lastIndexOf('string');
                searches from the last of the string
            var newString = string.slice(0, 1);
                takes two parameters starting point and ending point
            var subString = string.substr(0, 5);
                takes a starting point and a length as arguments and returns a new string
                string.substring(0, 5); is same as substr but doesn't accept negative indexes
            var replaceString = string.replace('string', 'information');
                replaces 'string' with 'information'
            var changeCase = string.toUpperCase() or string.toLowerCase();
            var characterAt = string.charAt(2);
            string.trim();
                removes white spaces from begging and end of strings
            string.trimLeft();
            string.trimRight();
            string.split(' ');
                splits the string into an array using a designated delimiter character to mark the split
        </p>

        <h3>Scopes</h3>
        <p>
            Scope defines which objects, functions and variables are available in a section of code.
        </p>

        <h3>Functions</h3>
        <p>
            You can define a function by statement:
                function somefunc(){}
            or by expression:
                var somefunc = function(){}
            A function has code to execute in the body. There are three ways to invoke a function.
            call: 
            apply: 
            bind:
                    Closure
            Closure is a function and the lexical environment in witch it was declared.
            Closures are mostly functions within functions that have access to the local and parent variables but no direct access from outside the parent function.
            In a closure the function has access to the parent function scope and all the scopes of that parent.
            The returned function stores the data available to it at the time of invocation thereby CLOSING the variable data to modification.
                    Lexical Scoping
            Lexical scope means the data available at the time of declaration in the current scope.
                    Javascript OOP
            The name of a constructor function should be capitalized.
            ES6 uses a capitalized class name with the constructor keyword.
            Call the constructor function with the new keyword.
        </p>

        <h3>Math Operators</h3>
        <p>
            The % (modules) means the remainder of the devision.
        </p>

        <h3>AJAX</h3>
        <p>
            Asynchronous
            Javascript
            And
            XML
        </p>

        <h3>Fetch API</h3>
        <p>
            Similar to JQuery AJAX
        </p>

        <h3>Javascript Promises</h3>
        <p>
            At their most basic, promises are a bit like event listeners.
                A promise can only succeed or fail
                A promise is set once(failed or succeeded) and can't be changed.
                A promise can be:
                    fulfilled - The action relating to the promise succeeded
                    rejected - the action relating to the promise failed
                    pending - Hasn't fulfilled or rejected
                    settled - Has fulfilled or rejected
        </p>

        <h3>Call Apply Bind</h3>
        <h2>Quotes</h2>
        <label for="company">Company: </label>
        <input type="text" name="company" id="company" value="apple">
        <br>
        <button onclick="fetchQuote()">Get Quote Every 3 seconds</button>
        <p>
            BIND!
            function fetchQuote() {
                var company = document.getElementById('company').value;
                let quote = new StockQuote(company);
                setInterval(quote.getQuote.bind(quote), 3000);
            }
            The bind sets the scope of the setInterval to the lexical scope of the quote variable instead of the global that it normally runs in.

            APPLY!
            let nums = [10, 4, 5, 50, 1];
            console.log(Math.min.apply(null, nums));

            The first parameter is the context, in this case there is no specific context the second parameter is an array.

            var person = {
                firstName: 'Ernest',
                lastName: 'Peterson',
                getFullName: funciton(greeting) {
                    return greeting + '! ' + tis.firstName + ' ' + this. lastName;
                }
            };
            var person2 = {
                firstName: 'Not',
                lastName: 'Ernest'
            };
            console.log(person.getFullName('Hello'));
            console.log(person.getFullName.apply(person2, ['Hello']));

            The above applies the getFullName method to the context of person2 and passes the argument 'Hello' to it. 

            CALL
            Works the same as apply but the second parameter is a string instead of an array.

            BIND
            Bind can be used to create a function from the method:
            var newLastName = person.getFullName.bind(person2);
            newLastName('A big Hello to ');  // output: A big Hello to Not Ernest
        </p>

        <h3>Currying</h3>
        <p>
            Currying is the process of taking a function that accepts N arguments and turning it into a chained series of N functions each taking 1 argument. 

            function multi(a, b){return a * b;}
            var multi2 = multi.bind(this, 2);
            multi2(5);

            This creates a new function accepting one parameter and multiplying it by the bound parameter a.
        </p>

        <h3>Inheritance</h3>
        <p>
                ES5
            To get inheritance to work you have to first call the base class(constructor).
                function Alert(title) {
                    this.myTitle = title || 'alert';
                }
                function SuccessAlert(input) {
                    Alert.call(this, title); // calling the base class(constructor)
                    this.type = 'success';
                    console.log('successful exicutioin');
                }
            Then add the original prototype to the new class.
                SuccessAlert.prototype = Object.create(Alert.prototype);
            And finally re-set the prototype.
                SuccessAlert.prototype.constructor = SuccessAlert;

                ES6
            Simplifies the code for creating prototypes for a more linear appearance.
                class SuccessAlertES6 extends ES6Alert {
                    constructor(someTitleData) {
                        super(someTitleData); // calls the base class
                        console.log(someTitleData);
                        this.type = 'success';
                    }
                }
        </p>

        <h3>ES6</h3>
        <p>
            Not all browsers support es6 so use a transpiler like Babel or Typescript.
            You can use template literal to concatenate by wrapping the string in back ticks ( `some string` ) and using ( ${somevariable} ) to insert variables.
            function StockQuote(company) {
                this.company = company;
                this.title = company;
                this.showQuote = true;
                this.quotes = {
                    'apple': '60',
                    'ibm': '55',
                    'microsoft': '65'
                };
            }
            StockQuote.prototype.getQuote = function() {
                console.log(`title: ${this.title}`);
                console.log(this.quotes[this.company]);
            };
            To use the class and concise methods of es6 the above is re-factored to:
            class StockQuote {
                constructor(company) {
                this.company = company;
                this.title = company;
                this.showQuote = true;
                this.quotes = {
                    'apple': '60',
                    'ibm': '55',
                    'microsoft': '65'
                };
                } getQuote(){
                    console.log(`title: ${this.title}`);
                    console.log(this.quotes[this.company]);
                }
            }

        </p>
    </section>
    <section id="display"></section>

    <footer id="theFooter"></footer>

<script src="js/main.js"></script>
</body>
</html>